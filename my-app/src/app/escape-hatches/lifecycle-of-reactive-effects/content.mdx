import { WhiteCard, ColorCard, DeepDive, Highlight, CodeBlock, Pitfall, RedCard, AlertBanner } from '@app/components';

# Reactive Effects의 라이프사이클

Effect는 컴포넌트와 다른 라이프사이클을 가진다. 컴포넌트는 마운트, 업데이트 또는 언마운트 등의 라이프사이클이 있다. Effect는 동기화를 시작하고, 나중에 동기화를 중지하는 두 가지 작업만 할 수 있다. 이 사이클은 시간이 지남에 따라 변하는 props와 state에 의존하는 Effect의 경우 여러 번 발생할 수 있다. 리액트는 Effect의 종속성을 올바르게 지정했는지 확인하는 linter를 제공한다. 이렇게 하면 Effect가 최신의 props와 state에 동기화된다.

<WhiteCard title='You will learn'>
- Effect의 라이프사이클이 컴포넌트의 라이프사이클과 다른 점
- 각 개별 Effect를 분리해서 생각하는 방법
- Effect를 다시 동기화해야 하는 시기와 그 이유
- Effect의 dependency가 결정되는 방법
- 값이 Reactive하다는 것의 의미
- 빈 dependency 배열이 의미하는 것
- 리액트가 linter로 dependency이 올바른지 확인하는 방법
- linter가 동의하지 않을 때 해야 할 일
</WhiteCard>


# Effect의 라이프사이클

모든 리액트 컴포넌트는 동일한 라이프사이클을 거친다.

<br/>

- 컴포넌트가 화면에 추가되면 **마운트**된다.
- 컴포넌트는 일반적으로 상호작용에 대한 응답으로 새로운 props나 state를 수신하면 **업데이트**된다.
- 컴포넌트가 화면에서 제거되면 **언마운트**된다.

<br/>

컴포넌트에 대해 생각하는 좋은 방법이지만 Effect에 대해서는 생각하지 않는 것이 좋다.

대신 각 Effect를 컴포넌트의 라이프사이클과 독립적으로 생각해봐라. Effect는 외부 시스템을 현재 props와 state에 동기화하는 방법을 설명한다. 코드가 변경되면 동기화를 더 자주 또는 덜 자주 수행해야 한다. 

<br/>

이 점을 설명하기 위해 컴포넌트를 채팅 서버에 연결하는 Effect를 예로 들어보자.

<CodeBlock>
{`const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}`}
</CodeBlock>

Effect의 body에는 동기화 시작 방법이 명시되어 있다.


<CodeBlock>
{`const connection = createConnection(serverUrl, roomId);
connection.connect();`}
</CodeBlock>

클린업 함수는 동기화를 중지하는 방법을 명시한다.

<CodeBlock>
{`...
return () => {
    connection.disconnect();
};
...`}
</CodeBlock>

직관적으로 리액트는 컴포넌트가 마운트될 때 동기화를 시작하고 컴포넌트가 언마운트될 때 동기화를 중지할 것이라고 생각할 수 있다. 하지만 이것이 flow의 끝은 아니다. 때로는 컴포넌트가 마운트된 상태에서 동기화를 여러 번 시작하고 중지해야 할 수도 있다.

<br/>

왜 이런 일이 필요한지, 언제 발생하는지, 어떻게 이 동작을 제어할 수 있는지 살펴보자.

<ColorCard color='green' title='노트'>
일부 Effect는 클린업 함수를 전혀 반환하지 않는다. 대부분의 경우 함수를 반환하고 싶겠지만, 그렇지 않은 경우 리액트는 빈 클린업 함수를 반환한 것 처럼 동작한다.
</ColorCard>

# 동기화가 두 번 이상 수행되어야 하는 이유

이 `ChatRoom` 컴포넌트가 사용자가 드롭다운에서 선택한 `roomId` prop을 받는다고 가정해보자. 처음에 사용자가 `general`을 `roomId`로 선택했다고 가정해보자. 앱에 `general` 채팅방이 표시된다.

<CodeBlock>
{`const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}`}
</CodeBlock>

UI가 표시되면 리액트가 Effect를 실행하여 동기화를 시작한다. `general` 채팅방에 연결된다.

<CodeBlock>
{`function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
  }, [roomId]);
  // ...`}
</CodeBlock>

지금까지는 괜찮다.

<br/>

나중에 사용자가 드롭다운에서 다른 방(예: `travel`)을 선택한다. 먼저 리액트가 UI를 업데이트한다.

<CodeBlock>
{`function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}`}
</CodeBlock>

다음에 어떤 일이 일어날 지 생각해보세요. 사용자는 UI에서 `travel`이 선택된 대화방임을 알 수 있다. 하지만 가장 최근에 실행된 Effect는 여전히 `general` 채팅방에 연결되어 있다. `roomId` 프로퍼티가 변경되었기 때문에, Effect가 수행한 작업이 더 이상 UI와 일치하지 않는다.

<br/>

이 시점에서 리액트가 두 가지 작업을 수행하기를 원한다.

1. 이전 `roomId`와의 동기화 중지 (`general` 방 연결 끊기)
2. 새 `roomId`와의 동기화 시작 (`travel` 방에 연결)

<br/>

다행히도 님은 이미 이 두가지를 수행하는 방법을 리액트에 가르쳤습니다.
<CodeBlock>
{``}
</CodeBlock>
