import { WhiteCard, ColorCard, DeepDive, Highlight, CodeBlock, Pitfall, RedCard, AlertBanner } from '@app/components';
import { Tabs, TabList, TabPanels, Tab, TabPanel } from '@chakra-ui/react'

import Menu from './Menu';
import Menu2 from './Menu2';
import Menu3 from './Menu3';

# state 구조 선택

state를 잘 구조화하면 차이(수정과 디버깅이 편한 컴포넌트 - 버그가 끊임없이 발생하는 컴포넌트)를 만들 수 있다. 다음은  state를 구조화할 때 고려해야 할 몇 가지 팁이다.

<br/>

<WhiteCard title='You will learn'>
- 단일 상태 변수 vs 다중 상태 변수를 사용해야 하는 경우
- 상태 구성 수 피해야 할 사항
- 상태 구조와 관련된 일반적인 이슈를 해결하는 방법
</WhiteCard>

<br/>

- - -

## 상태 구조화 원칙

어떤 state를 가지는 컴포넌트를 작성할 때는, 얼마나 많은 상태 변수를 사용할지, 데이터의 모양은 어떻게 할지에 대해 선택해야 한다. suboptional state 구조를 사용하고도 올바른 프로그램을 작성할 수 있지만, 더 나은 선택을 할 수 있도록 하는 몇 가지 원칙이 있다.

<br/>

1. <b>관련 상태를 그룹화</b>
    - 항상 두 개 이상의 상태 변수를 동시에 업데이트하는 경우, 단일 상태 변수를 병합하는 것을 고려해라
2. <b>상태의 모순을 피해라. (Avoid contradictions in state)</b>
    - 여러 개의 상태가 서로 모순되거나, "불일치(disagree)"할 수 있는 방식으로 상태를 구성하면 실수가 발생할 여지가 있다. 
3. <b>중복 상태 방지(Avoid redundant state)</b>
    - 만약 렌더링 중에 컴포넌트의 props나 기존 state 변수로부터 어떤 정보를 계산할 수 있다면, 해당 정보를 해당 컴포넌트의 state에 넣지 말아야 한다.
4. <b>상태 중복을 피해라.(Avoid duplication)</b>
    - 동일한 데이터가 여러 상태 변수 간에 중복되거나, 중첩된 객체 내에 중복되면, 동기화된 상태를 유지하기가 어렵다. 가능하면 중복을 피해라.
5. <b>깊게 중첩된 상태는 피해라.</b>
    - 깊게 계층화된 상태는 업데이트하기가 쉽지 않다. 가능하면 상태를 평평한 방식으로 구성하는 것이 좋다.

<br/>

이러한 원칙의 목표는 실수 없이 상태를 쉽게 업데이트할 수 있도록 하는 것이다. state에서 redundant 와 duplicate data를 제거하면, 모든 데이터가 동기화 상태를 유지하는데 도움이 된다. 이는 데이터베이스 엔지니어가 버그 발생 가능성을 줄이기 위해 데이터베이스 구조를 "정규화"하는 것과 유사하다. 알버트 아인슈타일의 말을 빌리자면, "상태를 최대한 단순하게 만들어라 - 하지만 no simpler"

<br/>

이제 이러한 원칙이 실제로 어떻게 적용되는지 살펴보자.

- - -

## 관련 상태 그룹화

single state를 사용할지  multiple state를 사용할지 고민할 때가 있다. 

- multiple state
    <CodeBlock>
    {`const [x, setX] = useState(0);
   const [y, setY] = useState(0);`}
    </CodeBlock>
- single state
    <CodeBlock>
    {`const [position, setPosition] = useState({ x: 0, y: 0 });`}
    </CodeBlock>

<br/>

기술적으로는, 이 두가지 접근 방식을 모두 사용할 수 있다. 하지만 두 개의 상태 변수가 항상 함께 변경되는 경우에는 하나의 상태 변수로 통합하는 것이 좋다. 그러면 항상 동기화 상태를 유지하는 것을 잊지 않을 수 있다. 
이 예체에서처럼 - 커서를 움직이면 빨간색 점의 좌표가 모두 업데이트 되는 예제

<CodeBlock>
{`import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: 'translate($ {position.x}px, $ {position.y}px)',
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  )
}
`}
</CodeBlock>

데이터를 객체나 배열로 그룹화하는 또 다른 경우: 얼마나 많은 상태가 필요한지 모를 때 

예를 들어, 사용자가 사용자 정의 필드를 추가할 수 있는 form이 있을 때 유용

<Pitfall>
상태 변수가 객체인 경우, 다른 필드를 명시적으로 복사하지 않고는 그 안의 한 필드만 업데이트할 수 없다는 점을 기억해라. 예를 들어, 위 예제에서는 `setPosition({ x: 100 })`를 수행할 수 없다. 왜냐하면 `y` 프로퍼티가 없기 때문이다. `x`만 상태를 설정하려면 `setPosition({ ...position, x: 100 })`을 수행하거나 두 개의 상태 변수로 분할하여 `setX(100)`을 수행해야 한다.  
</Pitfall>

- - -

## 상태의 모순을 피해라.

다음은 `inSending`, `isSent` 상태 변수가 있는 호텔 피드백 form이다.

<CodeBlock>
{`import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isSent, setIsSent] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsSending(true);
    await sendMessage(text);
    setIsSending(false);
    setIsSent(true);
  }

  if (isSent) {
    return <h1>Thanks for feedback!</h1>
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button
        disabled={isSending}
        type="submit"
      >
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}
`}
</CodeBlock>

이 코드는 작동하지만, "불가능한" 상태에 대한 문을 열어두는 것이다. 예를 들어 `setIsSent` 와 `setIsSending`을 함께 호출하는 것을 잊어버리면 `setIsSent`와 `setIsSending`가 동시에 true가 되는 상황이 발생할 수 있다. 컴포넌트가 복잡할수록 어떤 일이 발생했는지 파악하기가 더 어려워진다.

<br/>

`setIsSent`와 `setIsSending`는 동시에 `true`가 되어서는 안되므로 세 가지 유효한 상태 중 하나를 취할 수 있는 하나의 상태 변수로 대체하는 것이 좋다: 

<CodeBlock>
{`const [status, setStatus] = useState<'typing' | 'sending' | 'sent'>('typing')`}
</CodeBlock>

<CodeBlock>
{`import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [status, setStatus] = useState('typing');

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('sending');
    await sendMessage(text);
    setStatus('sent');
  }

  const isSending = status === 'sending';
  const isSent = status === 'sent';

  if (isSent) {
    return <h1>Thanks for feedback!</h1>
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button
        disabled={isSending}
        type="submit"
      >
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}
`}
</CodeBlock>


가독성을 위해 일부 상수를 선언할 수도 있습니다.

<CodeBlock>
{`const isSending = status === 'sending';
const isSent = status === 'sent';`}
</CodeBlock>

상태 변수가 이니므로, 서로 동기화되지 않을까 걱정할 필요가 없다.

- - -

## redundant state를 피해라

렌더링 중에 컴포넌트의  props나 기존 상태 변수에서 일부 정보를 계산할 수 있는 경우 해당 정보를 해당 컴포넌트의 상태에 넣지 않아야 한다.


<br/>

예를 들어, 이 form을 봐라. 이 form 은 작동하지만 중복 상태를 찾을 수 있나요?


<CodeBlock>
{`import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
`}
</CodeBlock>

이 form에는 세 가지 상태 변수가 있다: `firstName`, `lastName`, `fullName`

<br/>
하지만, `fullName`은 중복된다. 렌더링 중에 언제든지 `firstName`과 `lastName`에서 `fullName`을 구할 수 있으므로 state에서 제거해라.

<CodeBlock>
{`const [firstName, setFirstName] = useState('');
 const [lastName, setLastName] = useState('');

 const fullName = firstName + ' ' + lastName;`}
</CodeBlock>

여기서 `fullName`은 상태 변수가 이니다. 대신, 렌더링 중에 계산된다.

<br/>

따라서, change 핸들러는 이를 업데이트하기 위해 특별한 작업을 수행할 필요가 없다. `setFirstName` 또는 `setLastName`을 호출하면 다시 렌더링이 트리거되고 다음 `fullName`이 새 데이터에서 계산된다.

<DeepDive>
### props를 상태 그대로 미러링하지 않기

redundant state의 일반적인 예는 다음과 같은 코드이다:

<CodeBlock>
{`function Message({ messageColor }) {
 const [color, setColor] = useState(messageColor);`}
</CodeBlock>

여기서 `color` 상태 변수는 `messageColor` props로 초기화된다. 문제는 부모 컴포넌트가 나중에 다른 값(예: `red`에서 `blue`로)을 props로 전달하면 `color` 상태 변수가 업데이트되지 않는다는 것이다. 이는 `color` 상태 변수가 `messageColor` props를 미러링하기 때문이다. 상태는 첫 번째 렌더링 중에만 초기화된다.

<br/>

그렇기 떄문에 상태 변수에 일부 prop을 미러링하면 혼동을 일으킬 수 있다. 대신 코드에서 `messageColor` props를 직접 사용해라. 더 짧은 이름을 지정하려면 상수를 사용해라.

<CodeBlock>
{`function Message({ messageColor }) {
  const color = messageColor;`}
</CodeBlock>

이렇게 하면 부모 컴포넌트에서 전달된 prop과 동기화되지 않는다.

<br/>

prop을 "미러링" 하는 것은 특정 prop에 대한 모든 업데이트를 무시하고 싶을 때만 의미가 있다.

컨벤션에 따라 prop 이름을 `initial`이나 `default`로 시작하여 새 값이 무시됨을 명확히 해라:

<CodeBlock>
{`function Message({ initialColor }) {
  // The 'color' state variable holds the *first* value of 'initialColor'.
  // Further changes to the 'initialColor' prop are ignored.
  const [color, setColor] = useState(initialColor);`}
</CodeBlock>

</DeepDive>


- - - 

## state에서 중복 피하기

이 menu list 컴포넌트를 사용하면 여러 가지 여행용 간식 중에서 하나의 간식을 선택할 수 있다.

<CodeBlock>
{`import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(
    items[0]
  );

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.title}
            {' '}
            <button onClick={() => {
              setSelectedItem(item);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
`}
</CodeBlock>

<WhiteCard>
  <Menu/>
</WhiteCard>

현재 선택된 항목은 `selectedItem` 상태 변수에 객체로 저장된다. 그러나 이것은 좋지 않다. `selectedItem`은 `items` 배열의 항목과 중복된다. 이는 항목 자체에 대한 정보가 두 곳에 중복된다는 것이다.

<br/>

이것이 왜 문제일까? 각 항목을 편집 가능하게 만들어보자:

<CodeBlock>
{`import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(
    items[0]
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }

  return (
    <>
      <h2>What's your travel snack?</h2> 
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedItem(item);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
`}
</CodeBlock>

<WhiteCard>
  <Menu2 />
</WhiteCard>

먼저 항목에서 "선택"을 클릭한 이후에 -> 편집하면 입력은 업데이트되지만 하단의 레이블에 편집 내용이 반영되지 않는 것을 확인할 수 있다. 이는 상태가 중복되어 있고 `selectedItem`을 업데이트하는 것을 잊었기 때문이다.

선택한 항목도 업데이트할 수 있지만 중복을 제거하는 것이 더 쉬운 수정 방법이다. 이 예제에서는 `selectedItem` 객체(`items` 내부 객체와 중복을 생성함) 대신 `selectedId`를 상태로 유지한 다음 `items` 배열에서 해당 ID를 가진 항목을 검색하여 `selectedItem`을 가져온다:

<CodeBlock>
{`import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);

  const selectedItem = items.find(item =>
    item.id === selectedId
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedId(item.id);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
`}
</CodeBlock>

<WhiteCard>
  <Menu3 />
</WhiteCard>

(또는, 선택한 인덱스를 상태로 유지할 수도 있습니다.)

이전에는 상태가 이렇게 복제되었습니다:

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedItem = {id: 0, title: 'pretzels'}`

하지만 변경 후에는 이렇게 되었습니다:

- `items = [{ id: 0, title: 'pretzels'}, ...]`
- `selectedId = 0`

중복은 사라지고, 필수 상태만 유지된다.

<br/>

이제 선택한 항목을 편집하면 아래 메시지가 즉시 업데이트된다.

이는 `setItems`가 리렌더링을 트리거 하고, `items.find(...)`가 업데이트된 제목의 item을 찾기 때문이다. 

<br/>

선택한 id만 필수적이므로 selected item을 state로 유지할 필요가 없다, 나머지는 렌더링 중에 계산할 수 있다. 

- - -

## 깊게 중첩된 state를 피해라.

행성, 대륙, 국가로 구성된 여행 계획을 상상해보세요. 이 예제에서처럼 중첩된 객체와 배열을 사용하여 상태를 구조호화하고 싶을 수 있다:


<Tabs variant='enclosed'>
  <TabList>
    <Tab>App.js</Tab>
    <Tab>places.js</Tab>
  </TabList>
  <TabPanels>
    <TabPanel>
      <CodeBlock>
      {`import { useState } from 'react';
import { initialTravelPlan } from './places.js';

function PlaceTree({ id, placesById }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      {childIds.length > 0 && (
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              placesById={placesById}
            />
          ))}
        </ol>
      )}
    </li>
  );
}

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);
  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            placesById={plan}
          />
        ))}
      </ol>
    </>
  );
}
`}
      </CodeBlock>
    </TabPanel>
    <TabPanel>
      <CodeBlock>
      {`export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 43, 47],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 27, 35]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  }, 
  3: {
    id: 3,
    title: 'Botswana',
    childIds: []
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: []
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: []
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: []
  }, 
  7: {
    id: 7,
    title: 'Morocco',
    childIds: []
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: []
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: []
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: []
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: []
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: []
  }, 
  14: {
    id: 14,
    title: 'Canada',
    childIds: []
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: []
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: []
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: []
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: []
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25, 26],   
  },
  20: {
    id: 20,
    title: 'China',
    childIds: []
  },
  21: {
    id: 21,
    title: 'Hong Kong',
    childIds: []
  },
  22: {
    id: 22,
    title: 'India',
    childIds: []
  },
  23: {
    id: 23,
    title: 'Singapore',
    childIds: []
  },
  24: {
    id: 24,
    title: 'South Korea',
    childIds: []
  },
  25: {
    id: 25,
    title: 'Thailand',
    childIds: []
  },
  26: {
    id: 26,
    title: 'Vietnam',
    childIds: []
  },
  27: {
    id: 27,
    title: 'Europe',
    childIds: [28, 29, 30, 31, 32, 33, 34],   
  },
  28: {
    id: 28,
    title: 'Croatia',
    childIds: []
  },
  29: {
    id: 29,
    title: 'France',
    childIds: []
  },
  30: {
    id: 30,
    title: 'Germany',
    childIds: []
  },
  31: {
    id: 31,
    title: 'Italy',
    childIds: []
  },
  32: {
    id: 32,
    title: 'Portugal',
    childIds: []
  },
  33: {
    id: 33,
    title: 'Spain',
    childIds: []
  },
  34: {
    id: 34,
    title: 'Turkey',
    childIds: []
  },
  35: {
    id: 35,
    title: 'Oceania',
    childIds: [36, 37, 38, 39, 40, 41, 42],   
  },
  36: {
    id: 36,
    title: 'Australia',
    childIds: []
  },
  37: {
    id: 37,
    title: 'Bora Bora (French Polynesia)',
    childIds: []
  },
  38: {
    id: 38,
    title: 'Easter Island (Chile)',
    childIds: []
  },
  39: {
    id: 39,
    title: 'Fiji',
    childIds: []
  },
  40: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: []
  },
  41: {
    id: 41,
    title: 'New Zealand',
    childIds: []
  },
  42: {
    id: 42,
    title: 'Vanuatu',
    childIds: []
  },
  43: {
    id: 43,
    title: 'Moon',
    childIds: [44, 45, 46]
  },
  44: {
    id: 44,
    title: 'Rheita',
    childIds: []
  },
  45: {
    id: 45,
    title: 'Piccolomini',
    childIds: []
  },
  46: {
    id: 46,
    title: 'Tycho',
    childIds: []
  },
  47: {
    id: 47,
    title: 'Mars',
    childIds: [48, 49]
  },
  48: {
    id: 48,
    title: 'Corn Town',
    childIds: []
  },
  49: {
    id: 49,
    title: 'Green Hill',
    childIds: []
  }
};
`}
      </CodeBlock>
    </TabPanel>
  </TabPanels>
</Tabs>


이제 이미 방문한 장소를 삭제하는 버튼을 추가하고 싶다고 가정해 보겠습니다. 어떻게 해야 할까요? 중첩된 상태를 업데이트하려면 변경된 부분부터 위쪽까지 개체의 복사본을 만들어야 합니다. 깊게 중첩된 장소를 삭제하려면 해당 상위 장소 체인 전체를 복사해야 합니다. 이러한 코드는 매우 장황할 수 있습니다.

상태가 너무 중첩되어 쉽게 업데이트할 수 없는 경우 상태를 "플랫"하게 만드는 것이 좋습니다. 다음은 이 데이터를 재구성할 수 있는 한 가지 방법입니다. 각 장소가 하위 장소의 배열을 갖는 트리와 같은 구조 대신 각 장소가 하위 장소 ID의 배열을 보유하도록 할 수 있습니다. 그런 다음 각 장소 ID에서 해당 장소로의 매핑을 저장합니다.

이 데이터 재구조화는 데이터베이스 테이블을 보는 것과 비슷할 수 있습니다:


<Tabs variant='enclosed'>
  <TabList>
    <Tab>App.js</Tab>
    <Tab>places.js</Tab>
  </TabList>
  <TabPanels>
    <TabPanel>
      <CodeBlock>
      {`import { useState } from 'react';
import { initialTravelPlan } from './places.js';

function PlaceTree({ id, placesById }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      {childIds.length > 0 && (
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              placesById={placesById}
            />
          ))}
        </ol>
      )}
    </li>
  );
}

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);
  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            placesById={plan}
          />
        ))}
      </ol>
    </>
  );
}

`}
      </CodeBlock>
    </TabPanel>
    <TabPanel>
      <CodeBlock>
      {`export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 43, 47],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 27, 35]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  }, 
  3: {
    id: 3,
    title: 'Botswana',
    childIds: []
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: []
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: []
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: []
  }, 
  7: {
    id: 7,
    title: 'Morocco',
    childIds: []
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: []
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: []
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: []
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: []
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: []
  }, 
  14: {
    id: 14,
    title: 'Canada',
    childIds: []
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: []
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: []
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: []
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: []
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25, 26],   
  },
  20: {
    id: 20,
    title: 'China',
    childIds: []
  },
  21: {
    id: 21,
    title: 'Hong Kong',
    childIds: []
  },
  22: {
    id: 22,
    title: 'India',
    childIds: []
  },
  23: {
    id: 23,
    title: 'Singapore',
    childIds: []
  },
  24: {
    id: 24,
    title: 'South Korea',
    childIds: []
  },
  25: {
    id: 25,
    title: 'Thailand',
    childIds: []
  },
  26: {
    id: 26,
    title: 'Vietnam',
    childIds: []
  },
  27: {
    id: 27,
    title: 'Europe',
    childIds: [28, 29, 30, 31, 32, 33, 34],   
  },
  28: {
    id: 28,
    title: 'Croatia',
    childIds: []
  },
  29: {
    id: 29,
    title: 'France',
    childIds: []
  },
  30: {
    id: 30,
    title: 'Germany',
    childIds: []
  },
  31: {
    id: 31,
    title: 'Italy',
    childIds: []
  },
  32: {
    id: 32,
    title: 'Portugal',
    childIds: []
  },
  33: {
    id: 33,
    title: 'Spain',
    childIds: []
  },
  34: {
    id: 34,
    title: 'Turkey',
    childIds: []
  },
  35: {
    id: 35,
    title: 'Oceania',
    childIds: [36, 37, 38, 39, 40, 41, 42],   
  },
  36: {
    id: 36,
    title: 'Australia',
    childIds: []
  },
  37: {
    id: 37,
    title: 'Bora Bora (French Polynesia)',
    childIds: []
  },
  38: {
    id: 38,
    title: 'Easter Island (Chile)',
    childIds: []
  },
  39: {
    id: 39,
    title: 'Fiji',
    childIds: []
  },
  40: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: []
  },
  41: {
    id: 41,
    title: 'New Zealand',
    childIds: []
  },
  42: {
    id: 42,
    title: 'Vanuatu',
    childIds: []
  },
  43: {
    id: 43,
    title: 'Moon',
    childIds: [44, 45, 46]
  },
  44: {
    id: 44,
    title: 'Rheita',
    childIds: []
  },
  45: {
    id: 45,
    title: 'Piccolomini',
    childIds: []
  },
  46: {
    id: 46,
    title: 'Tycho',
    childIds: []
  },
  47: {
    id: 47,
    title: 'Mars',
    childIds: [48, 49]
  },
  48: {
    id: 48,
    title: 'Corn Town',
    childIds: []
  },
  49: {
    id: 49,
    title: 'Green Hill',
    childIds: []
  }
};`}
      </CodeBlock>
    </TabPanel>
  </TabPanels>
</Tabs>

이제 상태가 "평평"("정규화"라고도 함)해졌으므로 중첩된 항목을 업데이트하는 것이 더 쉬워졌습니다.

이제 장소를 제거하려면 두 단계의 상태만 업데이트하면 됩니다:

부모 장소의 업데이트된 버전은 childIds 배열에서 제거된 ID를 제외해야 합니다.
루트 '테이블' 객체의 업데이트된 버전에는 상위 장소의 업데이트된 버전이 포함되어야 합니다.
다음은 이를 수행하는 방법에 대한 예시입니다:


<Tabs variant='enclosed'>
  <TabList>
    <Tab>App.js</Tab>
    <Tab>places.js</Tab>
  </TabList>
  <TabPanels>
    <TabPanel>
      <CodeBlock>
      {`import { useState } from 'react';
import { initialTravelPlan } from './places.js';

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);

  function handleComplete(parentId, childId) {
    const parent = plan[parentId];
    // Create a new version of the parent place
    // that doesn't include this child ID.
    const nextParent = {
      ...parent,
      childIds: parent.childIds
        .filter(id => id !== childId)
    };
    // Update the root state object...
    setPlan({
      ...plan,
      // ...so that it has the updated parent.
      [parentId]: nextParent
    });
  }

  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}

function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button onClick={() => {
        onComplete(parentId, id);
      }}>
        Complete
      </button>
      {childIds.length > 0 &&
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      }
    </li>
  );
}`}
      </CodeBlock>
    </TabPanel>
    <TabPanel>
      <CodeBlock>
      {`export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 43, 47],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 27, 35]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  }, 
  3: {
    id: 3,
    title: 'Botswana',
    childIds: []
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: []
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: []
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: []
  }, 
  7: {
    id: 7,
    title: 'Morocco',
    childIds: []
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: []
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: []
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: []
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: []
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: []
  }, 
  14: {
    id: 14,
    title: 'Canada',
    childIds: []
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: []
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: []
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: []
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: []
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25, 26],   
  },
  20: {
    id: 20,
    title: 'China',
    childIds: []
  },
  21: {
    id: 21,
    title: 'Hong Kong',
    childIds: []
  },
  22: {
    id: 22,
    title: 'India',
    childIds: []
  },
  23: {
    id: 23,
    title: 'Singapore',
    childIds: []
  },
  24: {
    id: 24,
    title: 'South Korea',
    childIds: []
  },
  25: {
    id: 25,
    title: 'Thailand',
    childIds: []
  },
  26: {
    id: 26,
    title: 'Vietnam',
    childIds: []
  },
  27: {
    id: 27,
    title: 'Europe',
    childIds: [28, 29, 30, 31, 32, 33, 34],   
  },
  28: {
    id: 28,
    title: 'Croatia',
    childIds: []
  },
  29: {
    id: 29,
    title: 'France',
    childIds: []
  },
  30: {
    id: 30,
    title: 'Germany',
    childIds: []
  },
  31: {
    id: 31,
    title: 'Italy',
    childIds: []
  },
  32: {
    id: 32,
    title: 'Portugal',
    childIds: []
  },
  33: {
    id: 33,
    title: 'Spain',
    childIds: []
  },
  34: {
    id: 34,
    title: 'Turkey',
    childIds: []
  },
  35: {
    id: 35,
    title: 'Oceania',
    childIds: [36, 37, 38, 39, 40, 41,, 42],   
  },
  36: {
    id: 36,
    title: 'Australia',
    childIds: []
  },
  37: {
    id: 37,
    title: 'Bora Bora (French Polynesia)',
    childIds: []
  },
  38: {
    id: 38,
    title: 'Easter Island (Chile)',
    childIds: []
  },
  39: {
    id: 39,
    title: 'Fiji',
    childIds: []
  },
  40: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: []
  },
  41: {
    id: 41,
    title: 'New Zealand',
    childIds: []
  },
  42: {
    id: 42,
    title: 'Vanuatu',
    childIds: []
  },
  43: {
    id: 43,
    title: 'Moon',
    childIds: [44, 45, 46]
  },
  44: {
    id: 44,
    title: 'Rheita',
    childIds: []
  },
  45: {
    id: 45,
    title: 'Piccolomini',
    childIds: []
  },
  46: {
    id: 46,
    title: 'Tycho',
    childIds: []
  },
  47: {
    id: 47,
    title: 'Mars',
    childIds: [48, 49]
  },
  48: {
    id: 48,
    title: 'Corn Town',
    childIds: []
  },
  49: {
    id: 49,
    title: 'Green Hill',
    childIds: []
  }
};`}
      </CodeBlock>
    </TabPanel>
  </TabPanels>
</Tabs>

state는 얼마든지 중첩할 수 있지만 'flat'하게 만들면 많은 문제를 해결할 수 있습니다. 상태를 더 쉽게 업데이트할 수 있고 중첩된 객체의 다른 부분에 중복이 생기지 않도록 할 수 있습니다.

<DeepDive>
### 메모리 사용량 개선

이상적으로는 태이블 객체에서 삭제된 항목(및 그 하위 항목)도 제거하여  메모리 사용량을 개선하는 것이 좋다. 이 버전은 그렇 게 한다. 또한 Immer를 사용하여 업데이트 로직을 더욱 간결하게 만들었다. 

<Tabs variant='enclosed'>
  <TabList>
    <Tab>App.js</Tab>
    <Tab>places.js</Tab>
    <Tab>package.json</Tab>
  </TabList>
  <TabPanels>
    <TabPanel>
      <CodeBlock>
      {`import { useImmer } from 'use-immer';
import { initialTravelPlan } from './places.js';

export default function TravelPlan() {
  const [plan, updatePlan] = useImmer(initialTravelPlan);

  function handleComplete(parentId, childId) {
    updatePlan(draft => {
      // Remove from the parent place's child IDs.
      const parent = draft[parentId];
      parent.childIds = parent.childIds
        .filter(id => id !== childId);

      // Forget this place and all its subtree.
      deleteAllChildren(childId);
      function deleteAllChildren(id) {
        const place = draft[id];
        place.childIds.forEach(deleteAllChildren);
        delete draft[id];
      }
    });
  }

  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}

function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button onClick={() => {
        onComplete(parentId, id);
      }}>
        Complete
      </button>
      {childIds.length > 0 &&
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      }
    </li>
  );
}
`}
      </CodeBlock>
    </TabPanel>
    <TabPanel>
      <CodeBlock>
      {`export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 43, 47],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 27, 35]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  }, 
  3: {
    id: 3,
    title: 'Botswana',
    childIds: []
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: []
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: []
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: []
  }, 
  7: {
    id: 7,
    title: 'Morocco',
    childIds: []
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: []
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: []
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: []
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: []
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: []
  }, 
  14: {
    id: 14,
    title: 'Canada',
    childIds: []
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: []
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: []
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: []
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: []
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25, 26],   
  },
  20: {
    id: 20,
    title: 'China',
    childIds: []
  },
  21: {
    id: 21,
    title: 'Hong Kong',
    childIds: []
  },
  22: {
    id: 22,
    title: 'India',
    childIds: []
  },
  23: {
    id: 23,
    title: 'Singapore',
    childIds: []
  },
  24: {
    id: 24,
    title: 'South Korea',
    childIds: []
  },
  25: {
    id: 25,
    title: 'Thailand',
    childIds: []
  },
  26: {
    id: 26,
    title: 'Vietnam',
    childIds: []
  },
  27: {
    id: 27,
    title: 'Europe',
    childIds: [28, 29, 30, 31, 32, 33, 34],   
  },
  28: {
    id: 28,
    title: 'Croatia',
    childIds: []
  },
  29: {
    id: 29,
    title: 'France',
    childIds: []
  },
  30: {
    id: 30,
    title: 'Germany',
    childIds: []
  },
  31: {
    id: 31,
    title: 'Italy',
    childIds: []
  },
  32: {
    id: 32,
    title: 'Portugal',
    childIds: []
  },
  33: {
    id: 33,
    title: 'Spain',
    childIds: []
  },
  34: {
    id: 34,
    title: 'Turkey',
    childIds: []
  },
  35: {
    id: 35,
    title: 'Oceania',
    childIds: [36, 37, 38, 39, 40, 41,, 42],   
  },
  36: {
    id: 36,
    title: 'Australia',
    childIds: []
  },
  37: {
    id: 37,
    title: 'Bora Bora (French Polynesia)',
    childIds: []
  },
  38: {
    id: 38,
    title: 'Easter Island (Chile)',
    childIds: []
  },
  39: {
    id: 39,
    title: 'Fiji',
    childIds: []
  },
  40: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: []
  },
  41: {
    id: 41,
    title: 'New Zealand',
    childIds: []
  },
  42: {
    id: 42,
    title: 'Vanuatu',
    childIds: []
  },
  43: {
    id: 43,
    title: 'Moon',
    childIds: [44, 45, 46]
  },
  44: {
    id: 44,
    title: 'Rheita',
    childIds: []
  },
  45: {
    id: 45,
    title: 'Piccolomini',
    childIds: []
  },
  46: {
    id: 46,
    title: 'Tycho',
    childIds: []
  },
  47: {
    id: 47,
    title: 'Mars',
    childIds: [48, 49]
  },
  48: {
    id: 48,
    title: 'Corn Town',
    childIds: []
  },
  49: {
    id: 49,
    title: 'Green Hill',
    childIds: []
  }
};
`}
      </CodeBlock>
    </TabPanel>
    <TabPanel>
      <CodeBlock>
      {`{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}`}
      </CodeBlock>
    </TabPanel>
  
  </TabPanels>
</Tabs>

</DeepDive>

때로는 중첩된 상태의 일부를 하위 컴포넌트로 이동하여 상태 중첩을 줄일 수도 있습니다. 이 방법은 항목에 마우스 호버 여부와 같이 저장할 필요가 없는 임시 UI 상태에 효과적입니다.

<WhiteCard title='요약'>
- 두 개의 상태 변수가 항상 함께 업데이트되는 경우, 두 변수를 하나로 병합하는 것이 좋습니다.
- "불가능한" 상태를 만들지 않도록 상태 변수를 신중하게 선택하세요.
- 업데이트 실수를 줄일 수 있는 방식으로 상태를 구성하세요.
- 상태를 동기화할 필요가 없도록 중복 및 중복 상태를 피하세요.
- 특별히 업데이트를 방지하려는 경우가 아니라면 props을 상태에 넣지 마세요.
- selection과 같은 UI 패턴의 경우 개체 자체 대신 ID 또는 인덱스를 상태로 유지하세요.
- 깊게 중첩된 상태를 업데이트하는 것이 복잡하다면 플랫화하세요.
</WhiteCard>

