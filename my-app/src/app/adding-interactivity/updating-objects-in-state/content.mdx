import { DeepDive } from '@app/components/DeepDive';
import { Highlight } from '@app/components/Highlight';
import { CodeBlock } from '@app/components/CodeBlock';
import { Pitfall } from '@app/components/Pitfall';
import { RedCard } from '@app/components/RedCard';
import { WhiteCard } from '@app/components/WhiteCard';
import { ColorCard } from '@app/components/ColorCard';
import MovingDot from "./MovingDot";
import MovingDot2 from "./MovingDot2";
import Form from "./Form";
import Form2 from "./Form2";

# 객체 상태 업데이트

상태는 객체를 포함한 모든 종류의 자바스크립트 값을 보유할 수 있다. 하지만 React 상태에서 보유하고 있는 객체를 직접 변경해서는 안 됩니다.

객체를 업데이트하고 싶을 때는, 새 객체를 만들고(또는 기존 객체의 복사본을 만들어라), 그 복사본을 사용할 상태를 설정해야 합니다.

<WhiteCard title='You will learn'>
- 객체로된 state를 올바르게 업데이트하는 방법
- 중첩된 객체를 변경하지 않고 업데이트하는 방법
- 불변성은 무엇이며, 그것을 깨뜨리지 않는 방법
- Immer로 객체 복사를 덜 반복적으로 만드는 방법
</WhiteCard>

- - -

## Mutation 이란?

모든 종류의 자바스크립트 값을 상태에 저장할 수 있습니다. 

<CodeBlock>
{`const [x, setX] = useState(0);`}
</CodeBlock>

지금까지 너는 위 코드 처럼 state를 숫자, 문자열, 불린값으로 작업헀다.

이러한 종류의 자바스크립트 값들은 "immutable"(불변) 이다. 즉, 값을 변경할 수 없거나 "read-only(읽기 전용)"를 의미한다.
값을 대체하기 위해서 제 렌더를 트리거 할 수 있다.

<CodeBlock>
{`setX(5);`}
</CodeBlock>

`x` 상태는 `0`에서 `5`로 변경되었지만 숫자 `0` 자체는 변경되지 않았습니다.

자바스크립트에서 숫자, 문자열, 부울과 같은 내장 요소는 변경할 수 없다.

이제, 객제의 state를 고려해보자.

<CodeBlock>
{`const [position, setPosition] = useState({ x: 0, y: 0 });`}
</CodeBlock>

기술적으로는, 객제 자체의 내용을 변경할 수 있다.  <b>이를 "mutation"이라고 한다:</b>


<CodeBlock>
{`position.x = 5;`}
</CodeBlock>

그러나 리액트에서 객체 상태는 기술적으로 변경 가능하지만, 숫자, 부울, 문자열과 같이 불변하는 것처럼 취급해야 한다.

객체를 변경하는 대신 항상 교체해야 한다.

- - -

## read-only로 state 취급하기

즉, 상태에 넣는 모든 자바스크립트 객체는 읽기 전용으로 취급해야 한다.

<br/>

이 예제에서는 현재 포인터 위치를 나타내는 상태를 객체로 유지한다. 

미리보기 영역을 터치하거나 커서를 이동하면 빨간색 점이 움직여야 하지만, 점은 초기 위치에 머물러 있다.


<CodeBlock>
{`import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: 'translate({position.x}px, {position.y}px)',
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  );
}
`}
</CodeBlock>

<MovingDot/>

문제는 이 코드에 있다.

<CodeBlock>
{`onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}`}
</CodeBlock>

이 코드는 이전 렌더링에서 위치에 할당된 객체를 직접 변경한다.
하지만 state setting 함수를 사용하지 않으면, 리액트는 객체가 변경되었다는 사실을 알지 못한다.

상태를 mutating 하는 것은 경우에 따라 작동할 수 있지만 권장하지 않는다.

렌더링에서 엑세스할 수 있는 상태 값은 읽기 전용으로 취급해야 한다.

이 케이스에서 리렌더링을 트리거하려면, 새 객체를 생성하고 state setting 함수를 사용하여 새 객체를 상태로 설정해야 한다.
<CodeBlock>
{`onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}`}
</CodeBlock>


`setPosition을 사용하면, 리액트에게 다음과 같이 지시하는 것이다:
- `position`을 이 새로운 객체로 바꿔라
- 그리고 이 컴포넌트를 다시 렌더링해라

<CodeBlock>
{`import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: 'translate({position.x}px, {position.y}px)',
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  );
}`}
</CodeBlock>
<MovingDot2/>

<DeepDive>
### 로컬 mutation은 괜찮다

이와 같은 코드는 상태의 기존 객체를 수정하기때문에 문제가 된다:
<CodeBlock>
{`position.x = e.clientX;
 position.y = e.clientY;`}
</CodeBlock>

하지만 아래와 같은 코드는 방금 생성한 새 객체를 변경하는 것이므로 전혀 문제가 되지 않는다.
<CodeBlock>
{`const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);`}
</CodeBlock>

사실 이렇게 작성하는 것과 완전히 동일하다.
<CodeBlock>
{`setPosition({
  x: e.clientX,
  y: e.clientY
});`}
</CodeBlock>

Mutation은 이미 존재하는 기존 상태 객체를 변경할 때만 문제가 된다. 방금 생성한 객체를 변경해도 다른 코드가 아직 참조하지 않으므로 괜찮다. 객체를 변경해도 해당 객체에 종속된 다른 객체에 실수로 영향을 미치지 않는다. 이를 <b>"local mutation"</b>이라고 한다. 렌더리하는 동안에도 로컬 mutation을 수행할 수 있다. 매우 편리하고 완전히 괜찮다!
</DeepDive>

## 스프레드 문법으로 객체를 복사하기

이전 예제에서, `position` 객체는 항상 현재 커서 포지션에 따라 새롭게 만들어졌었다. 그러나 종종, 기존 데이터를 새로 만드는 객체에 포함시키고 싶을 때가 있다.
예를 들어 form에서 하나의 필드만 업데이트하고, 다른 모든 필드에 대해서는 이전 값을 유지하고 싶을 수 있다.

<br/>
이러한 입력 필드는 `onChange` 핸들러가 상태를 mutate하기 때문에 작동하지 않습니다:
<CodeBlock>
{`import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
`}
</CodeBlock>
<Form/>

예를 들어, 이 줄은 과거 렌더링의 상태를 mutate한다:

<CodeBlock>
{`person.firstName = e.target.value;`}
</CodeBlock>

원하는 동작을 얻을 수 있는 가장 안정적인 방법은 새로운 객체를 생성하고, 이를 `setPerson`에 전달하는 것이다. 

하지만 여기서는 여러 필드 중 하라만 변경되었으므로, 기존 데이터도 복사하고 싶을 것이다.

<CodeBlock>
{`setPerson({
  firstName: e.target.value, // New first name from the input
  lastName: person.lastName,
  email: person.email
});`}
</CodeBlock>

모든 속성을 개별적으로 복사할 필요가 없도록 <b>스프레드 구문`...`</b>을 사용할 수 있다.

<CodeBlock>
{`setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value // But override this one
});`}
</CodeBlock>

이제 폼이 작동한다!

<br/>

각 입력 필드에 대해 별도의 상태 변수를 선언하지 않는 것에 주목해라.

<br/>

큰 양식에 경우, 모든 데이터를 객체에 그룹화하여 보관하는 것이 매우 편리하다. (올바르게 업데이트하기만 한다면)

<CodeBlock>
{`import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
`}
</CodeBlock>

<Form2/>

스프레드 문법은 "얕은" 구문으로, 한 단계 깊이까지만 복사된다는 점에 유의하세요.

따라서 속도는 빠르지만 중첩된 프로퍼티를 업데이트 하려면 두 번 이상 사용해야 한다는 의미이기도 하다.

<DeepDive>
### 여러 개의 필드에 한 개의 이벤트 핸들러 사용하면


객체 정의 내에서 `[]` 대괄호를 사용하여 동적 이름을 가진 프로퍼티를 지정할 수도 있다. 다음은 동일한 예시이지만 세 개의 다른 이벤트 핸들러 대신 하나의 이벤트 핸들러를 사용 한 예시이다.
<CodeBlock>
{`import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

// 여기 ⭐️⭐️
  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name="firstName"
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name="lastName"
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input
          name="email"
          value={person.email}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
`}
</CodeBlock>
여기서 `e.target.name`은 `<input>` DOM 요소에 지정된 `name` 속성을 참조합니다.
</DeepDive>

- - -
<CodeBlock>
{``}
</CodeBlock>
